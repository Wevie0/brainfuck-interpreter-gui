# brainfuck-interpreter-gui

## A Brainfuck Text Editor, Interpreter, and Turing Machine Simulator

An integrated development environment for the esolang brainfuck. It includes a text editor with syntax highlighting, an interpreter, debugging with breakpoints/stepping, and turing machine simulator.

This project is in fulfillment of the [CPSC 312 2024W1 project requirements](https://steven-wolfman.github.io/cpsc-312-website-2024W1/project.html).

## Team Members

Our team is:

+ Yod Golshani (80626666): optional awesome nickname 1
+ Auden Hafezi (96479712): optional awesome nickname 2
+ Benjamin McPhee (16096588): optional awesome nickname 3
+ Kevin Liu (87079844): optional awesome nickname 4
+ Shreyan Das (51692796): optional awesome nickname 5

We call ourselves: `hooglers`

## Acknowledgments

We surely built on the work of others! Here are resources and people we got support from:

+ [Codeblocks from the Brainfuck Wikipedia page](https://en.wikipedia.org/wiki/Brainfuck)
+ [kavehmz/brainfuck_examples](https://github.com/kavehmz/brainfuck_examples/tree/master)

## Product Pitch

Our full project idea is a complete integrated development environment (IDE) for brainfuck, including a text editor that can highlight, recommend, and autofill syntax, and an interpreter for debugging featuring breakpoints and stepping inspired by the CPSC 213 assembly stepper. This would feature a Turing machine simulator, a visual representation of the memory tape that would be demonstrably affected step by step by the user’s input. It would ideally be this complete package that any of the twenty-odd people interested in both brainfuck and haskell could use for at least half an hour of novelty and enjoyment. 

This builds on our haskell knowledge by looking into parsing using a parsing library (https://hackage.haskell.org/package/parsec) to identify matching brackets and parsing brainfuck code into tokens. Then, syntactic analysis is used for both syntax highlighting, making it so that different tokens are different colours and checking for syntax errors. Furthermore, we are extending our knowledge by making User Interfaces using the GI.Gtk library  (https://github.com/haskell-gi). 


## Minimal Viable Project
Our intended minimum viable product is a Haskell interpreter for brainfuck that allows the user to write brainfuck code in our editor, and watch its progression through a Turing machine simulator. This leads to us learning about new elements of Haskell, as crucially, our project includes a graphical user interface. We have not explored the capabilities of Haskell to create GUIs, therefore, we will gain significant knowledge through this process. In addition, we intend to use a parsing library to identify matching brackets in a simpler way than we have currently included in our proposal code. Learning how to use this library will allow us to improve the efficiency and readability of our code for interpreting brainfuck. 

Our MVP builds meaningfully towards our product pitch by creating a basic environment for developing brainfuck code, as well as an intuitive and fascinating way of stepping through said code. Ultimately, IDE’s typically include many features such as debuggers, build automation, syntax highlighting, a source code editor, and more. Our project will ultimately begin to build a usable and novel IDE by creating a source code editor that can ultimately parse and interpret brainfuck code. In addition, our concept of a Turing machine simulator provides a method of debugging unique to brainfuck code that would allow a developer to enhance their understanding. As this project was inspired by the CPSC 213 assembly stepper, we see value in our final product as it provides a specialized way for users to write and debug brainfuck code, allowing them to attain a deeper understanding of the language. Brainfuck is a niche programming language, so our IDE will provide an entertaining and useful way for people to experience brainfuck as a language.

Our project builds on the strengths of Haskell by leveraging pattern matching to match lexical tokens generated by the parser. Haskell also has excellent type safety and inference, making it near impossible to mix up different tokens with one another, unlike in a weakly typed language like TypeScript. Also, the executables created by Haskell are performant, making the final product fast. 

## Proof of Concept

For our proof of concept, we have begun with a basic implementation of the GUI we intend to create. This GUI will simulate a Turing machine, to display the effects of input brainfuck commands (parsed and built through Haskell). We have included a GUI test file that allows you to interact with the basic version of our GUI to see our concept for our final IDE. At this time, our GUI includes a brainfuck text entry box, which can then be used to run brainfuck code. Our final product will connect this GUI to our brainfuck interpreter. In this way, you will be able to write brainfuck code in our pseudo-IDE, and step through it using the Turing machine simulator. Our sample GUI inspires confidence that we should be able to complete our intended project, as brainfuck is a small language. Therefore, we should be able to create a GUI that allows you to step through the various actions one could include in brainfuck code. The GUI is a key element to our project, as our final product (the MVP) should allow you to write, edit, and view the progression of brainfuck code. Being able to view the code stepped through a Turing machine simulator is a key element.

### How to test and run the code: Haskell

Replace this section with instructions to us for how to test and run your code.

As it is currently set up, editing works best if you first `cd` into the `haskell` subdirectory and open VS Code on that directory (`code .`). There is a `Makefile` with some helpful aliases, but you can also just use `stack` as normal.

Note: We expect to be able to test your code by running `stack test`. Included among your tests should be some that demonstrate the core functionality of your code. (We will be running `make haskell-eval` from the project root.)

We should be able to further explore your code's functionality by running `stack ghci`, and you should instruct us on some interesting cases to try.

If you include instructions different from these, be **absolutely sure** that they will work well for us in whatever environment we run your code and that they will be as easy to use as the instructions above!
